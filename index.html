<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Invoice PDF Parser & Editor ‚Äî Steel/Aluminum Sublines</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    body{font-family:Arial, sans-serif;background:#f5f7fa;padding:20px}
    .container{max-width:1800px;margin:0 auto;background:#fff;border-radius:8px;box-shadow:0 2px 10px rgba(0,0,0,.1)}
    .header{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:#fff;padding:30px;border-radius:8px 8px 0 0}
    .header h1{margin-bottom:8px}
    .upload-section{padding:40px;text-align:center}
    .upload-box{border:3px dashed #cbd5e0;border-radius:8px;padding:40px;cursor:pointer;transition:.3s}
    .upload-box:hover{border-color:#667eea;background:#f7fafc}
    .upload-box.dragover{border-color:#667eea;background:#e6f0ff}
    #fileInput{display:none}
    .loading{padding:40px;text-align:center;display:none}
    .spinner{border:4px solid #f3f3f3;border-top:4px solid #667eea;border-radius:50%;width:50px;height:50px;animation:spin 1s linear infinite;margin:0 auto 20px}
    @keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}
    .controls{padding:20px;background:#f8f9fa;border-bottom:1px solid #dee2e6;display:none}
    .controls select{padding:10px;border:1px solid #ced4da;border-radius:4px;font-size:14px;min-width:400px;margin-right:10px}
    .controls button{padding:10px 20px;border:none;border-radius:4px;font-weight:600;cursor:pointer;margin-right:10px}
    .btn-success{background:#28a745;color:#fff}.btn-success:hover{background:#218838}
    .btn-primary{background:#007bff;color:#fff}.btn-primary:hover{background:#0056b3}
    .btn-danger{background:#dc3545;color:#fff}.btn-danger:hover{background:#c82333}
    .btn-info{background:#17a2b8;color:#fff}.btn-info:hover{background:#138496}
    .btn-warning{background:#ffc107;color:#212529}.btn-warning:hover{background:#e0a800}
    .btn-light{background:#f8f9fa;color:#212529;border:1px solid #ced4da}
    .btn-secondary{background:#6c757d;color:#fff}.btn-secondary:hover{background:#5a6268}
    .stats{padding:20px;display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:15px;background:#fff3cd;display:none}
    .stat{padding:15px;background:#fff;border-radius:4px;border-left:4px solid #ffc107}
    .stat-label{font-size:11px;color:#6c757d;text-transform:uppercase;margin-bottom:5px}
    .stat-value{font-size:20px;font-weight:700}
    .stat-value.error{color:#dc3545}.stat-value.success{color:#28a745}
    .stat input{width:100%;padding:6px;border:1px solid #ced4da;border-radius:3px;font-size:16px;font-weight:bold}
    .stat.editable{border-left-color:#007bff}
    .table-container{padding:20px;display:none}
    .table-header-wrapper{background:#343a40;overflow:auto}
    .table-header-wrapper::-webkit-scrollbar{display:none}
    .table-header-wrapper{scrollbar-width:none}
    .table-header{min-width:1200px}
    .table-header table{width:100%;border-collapse:collapse}
    .table-header th{background:#343a40;color:#fff;padding:12px 8px;text-align:left;font-weight:600;font-size:13px;border:none}
    .table-body-wrapper{max-height:560px;overflow:auto}
    .table-body{min-width:1200px}
    .table-body table{width:100%;border-collapse:collapse}
    .table-body td{padding:10px 8px;border-bottom:1px solid #dee2e6;background:#fff}
    .table-body tr:hover td{background:#f8f9fa}
    .table-body td input{width:100%;padding:6px;border:1px solid #ced4da;border-radius:3px;font-size:13px}
    .table-body td input:focus{outline:none;border-color:#667eea; box-shadow:0 0 0 2px rgba(102,126,234,.15)}
    .readonly{background:#e9ecef!important}
    .actions{text-align:center}
    .actions button{padding:4px 8px;font-size:12px;margin:0 2px}
    .inline-help{font-size:12px;color:#6c757d;margin-left:8px}

    .db-section{padding:20px;background:#e7f3ff;border-bottom:1px solid #b3d9ff;display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .db-status{display:inline-block;padding:5px 10px;border-radius:4px;font-size:12px;margin-left:10px}
    .db-loaded{background:#d4edda;color:#155724}
    .db-loading{background:#fff3cd;color:#856404}
    .db-error{background:#f8d7da;color:#721c24}
    .db-offline{background:#e2e3e5;color:#383d41}
    .db-info{font-size:12px;color:#004085;margin-top:5px;flex-basis:100%}

    .table-header table, .table-body table{table-layout:fixed}
    .table-header th:nth-child(1), .table-body td:nth-child(1){width:44px!important}
    .table-header th:nth-child(2), .table-body td:nth-child(2){width:210px!important}
    .table-header th:nth-child(3), .table-body td:nth-child(3){width:80px!important}
    .table-header th:nth-child(4), .table-body td:nth-child(4){width:56px!important}
    .table-header th:nth-child(5), .table-body td:nth-child(5){width:120px!important}
    .table-header th:nth-child(6), .table-body td:nth-child(6){width:120px!important}
    .table-header th:nth-child(7), .table-body td:nth-child(7){width:96px!important}
    .table-header th:nth-child(8), .table-body td:nth-child(8){width:80px!important}
    .table-header th:nth-child(9), .table-body td:nth-child(9){width:140px!important}
    .table-body td{padding:6px 6px}
    .table-body td input{width:100%;}
  </style>
</head>
<body>
<div class="container">
  <div class="header">
    <h1>üìÑ Invoice PDF Parser & Editor</h1>
    <p>Steel/Aluminum sublines below each main line. Export-ready.</p>
  </div>

  <div class="db-section" id="dbSection">
    <strong>Database Status:</strong>
    <span class="db-status db-loading" id="dbStatus">Loading database from repository...</span>
    <button class="btn-light" id="retryDbBtn" title="Retry loading from GitHub">Retry Load</button>
    <button class="btn-warning" id="offlineBtn" title="Skip DB load and work offline">Work Offline</button>
    <div class="db-info" id="dbInfo">Fetching updated_manki_db.xlsx from GitHub‚Ä¶ (You can start uploading PDFs now, database will load in background)</div>
  </div>

  <div class="upload-section" id="uploadSection">
    <div class="upload-box" id="uploadBox">
      <h2>üì§ Upload PDF Invoice</h2>
      <p style="margin-top:10px;color:#6c757d">Click or drag & drop your PDF file here</p>
      <input type="file" id="fileInput" accept=".pdf,application/pdf" />
    </div>
  </div>

  <div class="loading" id="loading">
    <div class="spinner"></div>
    <div><strong>Processing PDF...</strong></div>
  </div>

  <div class="alert" id="alert" style="display:none"></div>

  <div class="controls" id="controls">
    <select id="invoiceSelect"><option value="">Select an invoice...</option></select>
    <button class="btn-warning" onclick="exportToDescartes()">üìã Export to Descartes Template (All Invoices)</button>
    <button class="btn-success" onclick="exportToExcel()">üì• Export All to Excel</button>
    <button class="btn-info" onclick="addBlankRowForCurrent()">‚ûï Add Blank Row</button>
    <button class="btn-secondary" onclick="undoLast()" id="undoBtn" disabled>‚Ü∂ Undo Last</button>
    <button class="btn-primary" onclick="resetUpload()">üì§ New Upload</button>
    <span class="inline-help">Tip: Use Tab/Shift+Tab or Enter to move between fields. Edit <strong>Supplier</strong> before export.</span>
  </div>

  <div class="stats" id="stats">
    <div class="stat"><div class="stat-label">Invoice Number</div><div class="stat-value" id="statInvoice">-</div></div>
    <div class="stat editable"><div class="stat-label">Invoice Date (Editable)</div><input autocomplete="off" type="text" id="statDate" placeholder="MM/DD/YYYY" onchange="updateInvoiceField('invoice_date', this.value)"></div>
    <div class="stat editable"><div class="stat-label">Supplier (Editable)</div><input autocomplete="off" type="text" id="statSupplier" placeholder="Supplier name" onchange="updateInvoiceField('supplier', this.value)"></div>
    <div class="stat"><div class="stat-label">Total Line Items</div><div class="stat-value" id="statItems">0</div></div>
    <div class="stat editable"><div class="stat-label">Invoice Total (Editable)</div><input autocomplete="off" type="number" step="0.01" id="statTotal" placeholder="0.00" onchange="updateInvoiceTotal(this.value)"></div>
    <div class="stat"><div class="stat-label">Line Items Sum</div><div class="stat-value" id="statSum">$0.00</div></div>
    <div class="stat"><div class="stat-label">Difference</div><div class="stat-value" id="statDiff">$0.00</div></div>
  </div>

  <div class="table-container" id="tableContainer">
    <div class="table-header-wrapper">
      <div class="table-header">
        <table><thead><tr>
          <th style="width:48px">Pos</th>
          <th style="width:210px">Part Number</th>
          <th style="width:90px">Quantity</th>
          <th style="width:64px">Unit</th>
          <th style="width:120px">Unit Price</th>
          <th style="width:120px">Line Total</th>
          <th style="width:120px">Net Weight</th>
          <th style="width:80px">Country</th>
          <th style="width:140px">Actions</th>
        </tr></thead></table>
      </div>
    </div>
    <div class="table-body-wrapper">
      <div class="table-body">
        <table><tbody id="tableBody"></tbody></table>
      </div>
    </div>
  </div>
</div>

<script>
  /* =================== GLOBALS / UI WIRING =================== */
  pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

  // Global error handler to prevent page from breaking
  window.addEventListener('error', function(event) {
    console.error('Global error caught:', event.error);
    // Don't let errors completely break the app
    event.preventDefault();
  });

  let allData = [];
  let currentInvoice = '';
  let invoiceOrder = [];
  let uploadedPdfName = '';

  // DB globals (populated by loader below)
  let mankiDb = null;
  let htsCodesDb = null;
  let steelAlumDb = null;
  let supplierMidDb = null;
  let supplierMidIndex = [];

  // UNDO SYSTEM
  let undoStack = [];
  const MAX_UNDO_STACK = 50;

  function saveStateToUndo(action) {
    const state = {
      action: action,
      data: JSON.parse(JSON.stringify(allData)),
      currentInvoice: currentInvoice,
      timestamp: Date.now()
    };
    undoStack.push(state);
    if (undoStack.length > MAX_UNDO_STACK) {
      undoStack.shift();
    }
    updateUndoButton();
  }

  function updateUndoButton() {
    const btn = document.getElementById('undoBtn');
    if (undoStack.length > 0) {
      btn.disabled = false;
      const lastAction = undoStack[undoStack.length - 1].action;
      btn.title = `Undo: ${lastAction}`;
    } else {
      btn.disabled = true;
      btn.title = 'Nothing to undo';
    }
  }

  function undoLast() {
    if (undoStack.length === 0) {
      showAlert('Nothing to undo', 'error');
      return;
    }
    
    const lastState = undoStack.pop();
    allData = JSON.parse(JSON.stringify(lastState.data));
    currentInvoice = lastState.currentInvoice;
    
    if (currentInvoice) {
      loadInvoiceData();
    }
    
    updateUndoButton();
    showAlert(`Undid: ${lastState.action}`, 'success');
  }

  // focus hint + suppression to avoid double re-render stealing focus
  let focusHint = null;
  let suppressChangeOnce = false;

  const uploadBox = document.getElementById('uploadBox');
  const fileInput = document.getElementById('fileInput');
  const headerWrap = document.querySelector('.table-header-wrapper');
  const bodyWrap = document.querySelector('.table-body-wrapper');
  if(headerWrap && bodyWrap){
    let syncing=false;
    bodyWrap.addEventListener('scroll',()=>{ if(syncing) return; syncing=true; headerWrap.scrollLeft = bodyWrap.scrollLeft; syncing=false; });
    headerWrap.addEventListener('scroll',()=>{ if(syncing) return; syncing=true; bodyWrap.scrollLeft = headerWrap.scrollLeft; syncing=false; });
  }

  uploadBox.addEventListener('click', () => fileInput.click());
  fileInput.addEventListener('change', e => { const f = e.target.files && e.target.files[0]; if (f) handleFile(f); });
  uploadBox.addEventListener('dragover', e => { e.preventDefault(); uploadBox.classList.add('dragover'); });
  uploadBox.addEventListener('dragleave', () => uploadBox.classList.remove('dragover'));
  uploadBox.addEventListener('drop', e => { e.preventDefault(); uploadBox.classList.remove('dragover'); const f = e.dataTransfer.files && e.dataTransfer.files[0]; if (f) handleFile(f); });

  function isPdfFile(file){ const nameOk=(file.name||'').toLowerCase().endsWith('.pdf'); const typeOk=(file.type||'').toLowerCase()==='application/pdf'; return nameOk || typeOk; }

  function showAlert(msg,type='success'){
    const el=document.getElementById('alert'); el.textContent=msg; el.style.display='block';
    el.style.background = type==='error'?'#f8d7da':'#d4edda';
    el.style.color = type==='error'?'#721c24':'#155724';
    el.style.border = type==='error'?'1px solid #f5c6cb':'1px solid #c3e6cb';
    setTimeout(()=>{ el.style.display='none'; }, 4000);
  }

  async function handleFile(file){
    if(!isPdfFile(file)){ showAlert('Please upload a PDF file','error'); return; }
    uploadedPdfName = (file.name||'').replace(/\.pdf$/i,'');

    document.getElementById('uploadSection').style.display='none';
    document.getElementById('loading').style.display='block';

    try{
      const arrayBuffer = await file.arrayBuffer();
      const uint8 = new Uint8Array(arrayBuffer);
      const pdf = await pdfjsLib.getDocument({data:uint8}).promise;

      let fullText='';
      for(let i=1;i<=pdf.numPages;i++){
        try{
          const page = await pdf.getPage(i);
          const textContent = await page.getTextContent({includeMarkedContent:true});
          const items = (textContent && Array.isArray(textContent.items))? textContent.items:[];
          const pageText = items.map(it=> (it && typeof it.str==='string') ? it.str : '').join(' ');
          fullText += (pageText||'') + '\n';
        }catch(perPageErr){ console.warn('Failed to read page',i,perPageErr); }
      }

      if(!fullText.trim()){
        showAlert('‚ö†Ô∏è The PDF had no extractable text (it may be scanned). Try an OCR'd copy.','error');
        document.getElementById('uploadSection').style.display='block';
        return;
      }

      parseInvoices(fullText);

      if(allData.length>0){
        const invoiceCount = new Set(allData.map(d=>d.invoice_number)).size;
        showAlert(`‚úÖ Found ${invoiceCount} invoice(s) with ${allData.length} line items`,'success');
        setupInterface();
        // Clear undo stack on new upload
        undoStack = [];
        updateUndoButton();
      }else{
        showAlert('‚ö†Ô∏è No invoice data found in PDF.','error');
        document.getElementById('uploadSection').style.display='block';
      }
    }catch(err){
      console.error('PDF processing error:',err); showAlert('Error: '+(err.message||String(err)),'error');
      document.getElementById('uploadSection').style.display='block';
    }finally{
      document.getElementById('loading').style.display='none';
    }
  }

  function parseFloatSafe(s){ if(s==null) return NaN; const t=String(s).replace(/[\,\s]/g,''); const v=parseFloat(t); return isNaN(v)?NaN:v; }
  function fmt2(n){ const v=parseFloatSafe(n); return isNaN(v)?'':Number(v).toFixed(2); }

  /* =================== PARSER =================== */
  function parseInvoices(text){
    allData=[]; invoiceOrder=[]; text = String(text||'');

    const splits = text.split(/Customs\s+Invoice\s+(\d+)\s+from/gi);
    const invoiceGroups = {};

    for(let i=1;i<splits.length;i+=2){
      const invoiceNum = splits[i]; const sectionText = splits[i+1];
      if(!invoiceNum || !sectionText) continue;
      if(!invoiceGroups[invoiceNum]){ invoiceOrder.push(invoiceNum); invoiceGroups[invoiceNum]=''; }
      invoiceGroups[invoiceNum] += sectionText + '\n';
    }

    Object.keys(invoiceGroups).forEach(invoiceNum => {
      const sectionText = invoiceGroups[invoiceNum] || '';

      const dateMatch = sectionText.match(/^\s*(\d{2}\/\d{2}\/\d{4})/);
      const invoiceDate = dateMatch ? dateMatch[1] : '';

      const headerSlice = sectionText.substring(0,1200);
      let supplier='';
      const supplierPattern=/(R√ºdt Industrielacke GmbH & Co\. KG|Norix Lackfabrik GmbH & Co\. KG|Finalin GmbH & Co\. KG|Mankiewicz Coatings, LLC)/i;
      const supplierMatch = headerSlice.match(supplierPattern);
      if(supplierMatch){ supplier = supplierMatch[1].trim(); }

      let invoiceTotal='';
      const overallPattern=/Overall\s+amount\s+in\s+USD\s+([\d,]+\.?\d*)/gi;
      const overallMatches=[...sectionText.matchAll(overallPattern)];
      if(overallMatches.length) invoiceTotal = overallMatches.at(-1)[1].replace(/,/g,'');

      const UNIT_WORD = '(?:carton|bucket(?:s|\\(s\\))?|pail|tin|can|barrel|canister|cartridge|bottle(?:s|\\(s\\))?|piece(?:\\(s\\))?|can(?:\\(s\\))?|pail(?:\\(s\\))?|tin(?:\\(s\\))?|Kilogramme)';

      const linePatternA = new RegExp(
        String.raw`(\d+)\s+([A-Z0-9.\-]+)\s+([\d,]+\.?\d*)\s+` + UNIT_WORD + String.raw`\s*(?:\([^)]*\)\s*)?` +
        String.raw`x\s*([\d,]+\.?\d+)\s+([A-Z]+)\s+` +
        String.raw`([\d,]+\.?\d+)\s+([A-Z]+)\s+` +
        String.raw`([\d.,]+)\s+USD\/(FOZ|KG|GAL|QT|PT|CN|PC|L|CAT|TIN|BTL|BUC)\s+` +
        String.raw`([\d,]+\.?\d+)`,
        'gi'
      );

      const linePatternB = new RegExp(
        String.raw`(\d+)\s+([A-Z0-9.\-]+)\s+([\d,]+\.?\d*)\s+` + UNIT_WORD + String.raw`\s*` +
        String.raw`([\d,]+\.?\d+)\s+([A-Z]+)\s+` +
        String.raw`([\d.,]+)\s+USD\/(FOZ|KG|GAL|QT|PT|CN|PC|L|CAT|TIN|BTL|BUC)\s+` +
        String.raw`([\d,]+)\.?\d*`,
        'gi'
      );

      const positionsFound = new Set();
      const lineItems = [];

      function pushItem(c){
        const {position,partNumber,containerQty,perUnitQty,perUnitType,totalQty,totalUnit,unitPrice,priceUnit,lineTotal,matchIndex}=c;
        let quantity, unit;
        if(['CN','PC','CAT','TIN','BTL','BUC'].includes(priceUnit)){
          quantity = containerQty || totalQty; unit = priceUnit;
        }else if(['KG','GAL','PT','QT','FOZ','L'].includes(priceUnit)){
          quantity = totalQty; unit = priceUnit;
        }else if(priceUnit === totalUnit){
          quantity = totalQty; unit = priceUnit;
        }else{ quantity = totalQty; unit = priceUnit; }

        lineItems.push({
          invoice_number:invoiceNum,
          invoice_date:invoiceDate,
          invoice_total:invoiceTotal,
          supplier:supplier,
          position,
          part_number:partNumber,
          quantity, unit,
          unit_price:unitPrice,
          line_total:lineTotal,
          net_weight:'', country_of_origin:'',
          _matchIndex:matchIndex
        });
      }

      let mA; while((mA=linePatternA.exec(sectionText))!==null){
        const position=mA[1]; if(positionsFound.has(position)) continue; positionsFound.add(position);
        pushItem({
          position,
          partNumber:(mA[2]||'').slice(0,64),
          containerQty:(mA[3]||'').replace(/,/g,''),
          perUnitQty:(mA[4]||'').replace(/,/g,''),
          perUnitType:mA[5]||'',
          totalQty:(mA[6]||'').replace(/,/g,''),
          totalUnit:mA[7]||'',
          unitPrice:mA[8]||'',
          priceUnit:mA[9]||'',
          lineTotal:(mA[10]||'').replace(/,/g,''),
          matchIndex:mA.index ?? 0
        });
      }

      let mB; while((mB=linePatternB.exec(sectionText))!==null){
        const position=mB[1]; if(positionsFound.has(position)) continue; positionsFound.add(position);
        pushItem({
          position,
          partNumber:(mB[2]||'').slice(0,64),
          containerQty:null,
          perUnitQty:null,
          perUnitType:null,
          totalQty:(mB[3]||'').replace(/,/g,''),
          totalUnit:mB[4]||'',
          unitPrice:mB[5]||'',
          priceUnit:mB[6]||'',
          lineTotal:(mB[7]||'').replace(/,/g,''),
          matchIndex:mB.index ?? 0
        });
      }

      lineItems.sort((a,b)=>(a._matchIndex||0)-(b._matchIndex||0));

      const idxMap = lineItems.reduce((acc,it,i)=>{ acc[it.position]=i; return acc; }, {});

      const weightPattern = new RegExp(
        String.raw`Total\s+net\s+weight\s+per\s+PC\s*:\s*([\d,]+\.?\d*)\s*KG`,
        'ig'
      );
      const originPattern = /Country\s+of\s+origin\s*:\s*([A-Z]{2}|[A-Z]{3})/gi;
      const steelQtyPattern = new RegExp(
        String.raw`Quantity\s+per\s+PC\s*:\s*([\d,]+\.?\d*)\s*KG`,
        'gi'
      );
      const steelKgPattern = new RegExp(
        String.raw`Total\s+net\s+steel\s+weight\s+per\s+KG\s*:\s*([\d,]+\.?\d*)`,
        'gi'
      );
      const steelPricePattern = new RegExp(
        String.raw`([\d,]+\.?\d*)\s*USD\s*\/\s*KG`,
        'gi'
      );
      const steelTotalPattern = new RegExp(
        String.raw`Total\s+customs\s+value\s*:\s*([\d,]+\.?\d*)\s*USD`,
        'gi'
      );
      const aluminumQtyPattern = new RegExp(
        String.raw`Quantity\s+per\s+PC\s*:\s*([\d,]+\.?\d*)\s*KG`,
        'gi'
      );
      const aluminumKgPattern = new RegExp(
        String.raw`Total\s+net\s+aluminum\s+weight\s+per\s+KG\s*:\s*([\d,]+\.?\d*)`,
        'gi'
      );
      const aluminumPricePattern = new RegExp(
        String.raw`([\d,]+\.?\d*)\s*USD\s*\/\s*KG`,
        'gi'
      );
      const aluminumTotalPattern = new RegExp(
        String.raw`Total\s+customs\s+value\s*:\s*([\d,]+\.?\d*)\s*USD`,
        'gi'
      );

      function clean(s){ return String(s||'').replace(/[\r\n]+/g,'').replace(/\s{2,}/g,' ').trim(); }
      function flNorm(s){ const c=String(s||'').replace(/,/g,''); const v=parseFloat(c); return isNaN(v)?NaN:v; }

      const weightPieces = [];
      {
        let m; while((m=weightPattern.exec(sectionText))!==null){
          weightPieces.push({ idx: m.index, weight: m[1] });
        }
      }
      const originPieces = [];
      {
        let m; while((m=originPattern.exec(sectionText))!==null){
          originPieces.push({ idx: m.index, code: m[1] });
        }
      }

      for(let i=0; i<lineItems.length; i++){
        const item = lineItems[i];
        const after = (item._matchIndex || 0);
        const before = (i+1 < lineItems.length) ? (lineItems[i+1]._matchIndex || 999999) : 999999;
        const wpArr = weightPieces.filter(x => x.idx > after && x.idx < before);
        const orArr = originPieces.filter(x => x.idx > after && x.idx < before);
        if(wpArr[0]) item.net_weight = wpArr[0].weight;
        if(orArr[0]) item.country_of_origin = orArr[0].code;
      }

      const enriched = [];
      for(const item of lineItems){
        enriched.push(item);
        const after = item._matchIndex;
        const posList = lineItems.map(x=>x.position);
        const myIdx = posList.indexOf(item.position);
        const before = (myIdx+1 < posList.length) ? (lineItems[myIdx+1]._matchIndex || 999999) : 999999;
        const slice = sectionText.substring(after, before);

        let steelQty=NaN, steelTotalKg=NaN, steelPrice=NaN, steelTotal=NaN, steelCustomsUSD=NaN, steelAdd=false, alumQty=NaN, alumTotalKg=NaN, alumPrice=NaN, alumTotal=NaN, alumCustomsUSD=NaN, alumAdd=false;

        if(slice.includes('9903.81.91')){
          let mQ; while((mQ=steelQtyPattern.exec(slice))!==null){
            const raw = mQ[1].replace(/,/g,'');
            const val = parseFloat(raw);
            if(!isNaN(val)) steelQty = val;
          }
          let mK; while((mK=steelKgPattern.exec(slice))!==null){
            const raw = mK[1].replace(/,/g,'');
            const val = parseFloat(raw);
            if(!isNaN(val)) steelTotalKg = val;
          }
          let mP; while((mP=steelPricePattern.exec(slice))!==null){
            const raw = mP[1].replace(/,/g,'');
            const val = parseFloat(raw);
            if(!isNaN(val)) steelPrice = val;
          }
          let mT; while((mT=steelTotalPattern.exec(slice))!==null){
            const raw = mT[1].replace(/,/g,'');
            const val = parseFloat(raw);
            if(!isNaN(val)) steelTotal = val;
          }
          if(!isNaN(steelTotalKg) && !isNaN(steelPrice)){
            steelCustomsUSD = steelTotalKg * steelPrice;
          } else if(!isNaN(steelTotal)){
            steelCustomsUSD = steelTotal;
          }
          const parentQty = flNorm(item.quantity);
          if(!isNaN(steelCustomsUSD) && !isNaN(parentQty)){
            if(steelCustomsUSD>0 && parentQty>0){
              const parentTotal = flNorm(item.line_total);
              if(!isNaN(parentTotal) && parentTotal>=steelCustomsUSD){
                const parentAdjusted = parentTotal - steelCustomsUSD;
                item.line_total = fmt2(Math.max(0,parentAdjusted));
                steelAdd=true;
              }else if(steelCustomsUSD>0){
                steelAdd=true;
              }
            }
          }
        }

        if(slice.includes('9903.85.08')){
          let mQ; while((mQ=aluminumQtyPattern.exec(slice))!==null){
            const raw = mQ[1].replace(/,/g,'');
            const val = parseFloat(raw);
            if(!isNaN(val)) alumQty = val;
          }
          let mK; while((mK=aluminumKgPattern.exec(slice))!==null){
            const raw = mK[1].replace(/,/g,'');
            const val = parseFloat(raw);
            if(!isNaN(val)) alumTotalKg = val;
          }
          let mP; while((mP=aluminumPricePattern.exec(slice))!==null){
            const raw = mP[1].replace(/,/g,'');
            const val = parseFloat(raw);
            if(!isNaN(val)) alumPrice = val;
          }
          let mT; while((mT=aluminumTotalPattern.exec(slice))!==null){
            const raw = mT[1].replace(/,/g,'');
            const val = parseFloat(raw);
            if(!isNaN(val)) alumTotal = val;
          }
          if(!isNaN(alumTotalKg) && !isNaN(alumPrice)){
            alumCustomsUSD = alumTotalKg * alumPrice;
          } else if(!isNaN(alumTotal)){
            alumCustomsUSD = alumTotal;
          }
          const parentQty = flNorm(item.quantity);
          if(!isNaN(alumCustomsUSD) && !isNaN(parentQty)){
            if(alumCustomsUSD>0 && parentQty>0){
              const parentTotal = flNorm(item.line_total);
              if(!isNaN(parentTotal) && parentTotal>=alumCustomsUSD){
                const parentAdjusted = parentTotal - alumCustomsUSD;
                item.line_total = fmt2(Math.max(0,parentAdjusted));
                alumAdd=true;
              }else if(alumCustomsUSD>0){
                alumAdd=true;
              }
            }
          }
        }

        const steelUnit = isNaN(steelTotalKg) ? 'KG' : 'KG';
        const alumUnit  = isNaN(alumTotalKg) ? 'KG' : 'KG';

        if(steelAdd>0){
          enriched.push({
            invoice_number: invoiceNum,
            invoice_date: invoiceDate,
            invoice_total: invoiceTotal,
            supplier: supplier,
            position: `${item.position}S`,
            part_number: `Steel - ${item.part_number}`.slice(0,64),
            quantity: isNaN(steelQty)?'':fmt2(steelQty),
            unit: steelUnit,
            unit_price: '',
            line_total: fmt2(steelCustomsUSD),
            net_weight: '',
            country_of_origin: item.country_of_origin || ''
          });
        }

        if(alumAdd>0){
          enriched.push({
            invoice_number: invoiceNum,
            invoice_date: invoiceDate,
            invoice_total: invoiceTotal,
            supplier: supplier,
            position: `${item.position}A`,
            part_number: `Aluminum - ${item.part_number}`.slice(0,64),
            quantity: isNaN(alumQty)?'':fmt2(alumQty),
            unit: alumUnit,
            unit_price: '',
            line_total: fmt2(alumCustomsUSD),
            net_weight: '',
            country_of_origin: item.country_of_origin || ''
          });
        }
      }

      enriched.forEach(it=>{ delete it._matchIndex; });
      if(enriched.length===0){
        enriched.push({invoice_number:invoiceNum,invoice_date:invoiceDate,invoice_total:invoiceTotal,supplier:supplier,position:'',part_number:'',quantity:'',unit:'',unit_price:'',line_total:'',net_weight:'',country_of_origin:''});
      }

      allData.push(...enriched);
    });
  }

  /* =================== UI RENDERING / EDITING =================== */

  function _rankSuffix(s){ return s===''?0:(s==='S'?1:2); }
  function _parsePos(p){
    const m=String(p||'').match(/^(\d+(?:[.,]\d+)?)([A-Za-z]?)$/);
    if(!m) return {n:999999, s:''};
    return { n: parseFloat(String(m[1]).replace(',', '.')), s:(m[2]||'').toUpperCase() };
  }

  function setupInterface(){
    const select=document.getElementById('invoiceSelect');
    select.innerHTML='<option value="">Select an invoice...</option>';
    const invoices={};
    allData.forEach(item=>{ if(!invoices[item.invoice_number]){ invoices[item.invoice_number]={date:item.invoice_date,supplier:item.supplier,total:item.invoice_total,itemCount:0}; } invoices[item.invoice_number].itemCount++; });
    invoiceOrder.forEach(num=>{ const inv = invoices[num] || {date:'',supplier:'',total:0,itemCount:0}; const total=parseFloat(inv.total||0).toLocaleString('en-US',{minimumFractionDigits:2}); const opt=document.createElement('option'); opt.value=num; opt.textContent=`Invoice ${num} (${inv.itemCount} items) - ${inv.date} - ${inv.supplier} - $${total}`; select.appendChild(opt); });
    document.getElementById('controls').style.display='block';
    select.addEventListener('change', function(){ currentInvoice=this.value; if(currentInvoice) loadInvoiceData(); else hideDataView(); });
  }

  function hideDataView(){
    document.getElementById('stats').style.display='none';
    document.getElementById('tableContainer').style.display='none';
  }

  // Tab order counter for keyboard nav
  let _tabCounter = 1;
  const EDIT_KEYS = ['position','part_number','quantity','unit','unit_price','line_total','net_weight','country_of_origin'];
  function nextKeyOf(k, dir){
    const i = EDIT_KEYS.indexOf(k);
    if(i===-1) return 'part_number';
    const j = i + (dir>0?1:-1);
    if(j<0) return EDIT_KEYS[0];
    if(j>=EDIT_KEYS.length) return EDIT_KEYS[EDIT_KEYS.length-1];
    return EDIT_KEYS[j];
  }
  function sanitizeId(s){ return String(s||'').replace(/[^A-Za-z0-9_-]/g,'_'); }
  function tryApplyFocusHint(){
    if(!focusHint || !currentInvoice) return;
    const posId = sanitizeId(focusHint.pos);
    const targetId = `cell-${posId}-${focusHint.key}`;
    const el = document.getElementById(targetId);
    if(el){ el.focus(); try{ el.select(); }catch(_){} }
    focusHint = null;
  }

  function loadInvoiceData(){
    let items = allData.filter(d=>d.invoice_number===currentInvoice);
    if(items.length===0){ const meta={invoice_number:currentInvoice,invoice_date:'',invoice_total:'',supplier:''}; items=[{...meta,position:'',part_number:'',quantity:'',unit:'',unit_price:'',line_total:'',net_weight:'',country_of_origin:''}]; }

    items.sort((a,b)=>{
      const A=_parsePos(a.position), B=_parsePos(b.position);
      if(A.n!==B.n) return A.n-B.n;
      return _rankSuffix(A.s) - _rankSuffix(B.s);
    });

    const meta = items[0]||{};
    document.getElementById('statInvoice').textContent=currentInvoice;
    document.getElementById('statDate').value=meta.invoice_date||'';
    document.getElementById('statSupplier').value=meta.supplier||'';
    document.getElementById('statTotal').value=meta.invoice_total||'';
    document.getElementById('statItems').textContent=String(items.length);

    const tbody=document.getElementById('tableBody');
    tbody.innerHTML='';
    _tabCounter = 1;
    items.forEach((row, idx)=>{ tbody.appendChild(renderRow(row, idx)); });

    document.getElementById('stats').style.display='grid';
    document.getElementById('tableContainer').style.display='block';

    recomputeStats();
    tryApplyFocusHint();
  }

  function renderRow(row, idx){
    const tr=document.createElement('tr');

    function cellInput(val, key, readonly=false){
      const td=document.createElement('td');
      const inp=document.createElement('input');
      const posId = sanitizeId(row.position);
      inp.id = `cell-${posId}-${key}`;
      inp.value = (val==null?'':String(val));
      if(readonly) inp.classList.add('readonly');
      inp.readOnly = readonly;

      inp.setAttribute('tabindex', String(_tabCounter++));

      // ENTER: commit & focus next via re-render (suppress blur/change)
      inp.addEventListener('keydown', (ev)=>{
        if(ev.key==='Enter' && !readonly){
          ev.preventDefault();
          suppressChangeOnce = true;
          const targetKey = nextKeyOf(key, +1);
          focusHint = { pos: String(row.position||''), key: targetKey };
          updateCell(idx, key, inp.value);
        }
      });

      // TAB / SHIFT+TAB: commit & move via re-render (suppress blur/change)
      inp.addEventListener('keydown', (ev)=>{
        if(ev.key === 'Tab' && !readonly){
          ev.preventDefault();
          suppressChangeOnce = true;
          const dir = ev.shiftKey ? -1 : 1;
          const targetKey = nextKeyOf(key, dir);
          focusHint = { pos: String(row.position||''), key: targetKey };
          updateCell(idx, key, inp.value);
        }
      });

      // Change (fires on blur). If we just handled Enter/Tab, skip once.
      inp.addEventListener('change',()=>{
        if(suppressChangeOnce){ suppressChangeOnce=false; return; }
        if(!readonly) updateCell(idx,key,inp.value);
      });

      td.appendChild(inp); return td;
    }

    function btn(txt, cls, handler){ const b=document.createElement('button'); b.textContent=txt; b.className=cls; b.onclick=handler; return b; }

    tr.appendChild(cellInput(row.position,'position'));
    tr.appendChild(cellInput(row.part_number,'part_number'));
    tr.appendChild(cellInput(row.quantity,'quantity'));
    tr.appendChild(cellInput(row.unit,'unit'));
    tr.appendChild(cellInput(row.unit_price,'unit_price'));
    tr.appendChild(cellInput(row.line_total,'line_total'));
    tr.appendChild(cellInput(row.net_weight,'net_weight'));
    tr.appendChild(cellInput(row.country_of_origin,'country_of_origin'));

    const actTd=document.createElement('td'); actTd.className='actions';
    actTd.appendChild(btn('‚ûï Below','btn-info',()=>addRowBelow(idx)));
    actTd.appendChild(btn('üóëÔ∏è','btn-danger',()=>deleteRow(idx)));
    tr.appendChild(actTd);

    return tr;
  }

  function updateCell(rowIndex, key, value){
    saveStateToUndo(`Edit ${key}`);
    
    const items = allData.filter(d=>d.invoice_number===currentInvoice);
    const sortedIdxMap = items
      .map((row, idx)=>({row, idx}))
      .sort((a,b)=>{
        const A=_parsePos(a.row.position), B=_parsePos(b.row.position);
        if(A.n!==B.n) return A.n-B.n;
        return _rankSuffix(A.s) - _rankSuffix(B.s);
      })
      .map(x=>x.idx);

    const realIdx = sortedIdxMap[rowIndex];
    const recs = allData.filter(d=>d.invoice_number===currentInvoice);

    const prevVal = recs[realIdx][key];
    recs[realIdx][key]=value;

    if (key === 'position' && focusHint && String(focusHint.pos) === String(prevVal || '')) {
      focusHint.pos = String(value || '');
    }

    // Auto-lookup steel/aluminum part numbers from database when user manually adds them
    if (key === 'part_number' && value) {
      const valueLower = String(value).toLowerCase().trim();
      const isSteel = /^steel$/i.test(valueLower);
      const isAlum = /^(alum|aluminum)$/i.test(valueLower);
      
      if (isSteel || isAlum) {
        // Find parent line - either by position suffix or by finding line above
        let parentLine = null;
        const currentPos = String(recs[realIdx].position || '');
        
        // First try: if position ends with S or A, find parent by base position
        if (/[SA]$/i.test(currentPos)) {
          const basePos = currentPos.replace(/[SA]$/i, '');
          parentLine = recs.find(r => String(r.position||'') === basePos);
        }
        
        // Second try: find the line immediately above in sorted order
        if (!parentLine && realIdx > 0) {
          parentLine = recs[realIdx - 1];
        }
        
        // If we found a parent line, look up the correct part number
        if (parentLine && parentLine.part_number) {
          const parentBasePart = extractBasePartNumber(parentLine.part_number);
          if (parentBasePart) {
            const parentTariffs = lookupTariffs(parentBasePart);
            // Find first non-98/99 tariff
            const tariffForSubline = parentTariffs.find(t => !String(t).startsWith('98') && !String(t).startsWith('99')) || null;
            
            if (tariffForSubline) {
              const lookedUpPartNum = getSteelAlumPartNumber(tariffForSubline, isSteel ? 'Steel' : 'Aluminum');
              recs[realIdx].part_number = lookedUpPartNum;
            }
          }
        }
      }
    }

    if (key === 'line_total') {
      const pos = String(recs[realIdx].position || '');
      if (/[SA]$/i.test(pos)) {
        const basePos = pos.replace(/[SA]$/i, '');
        const parent = recs.find(r => String(r.position||'') === basePos);
        if (parent) {
          const parentTotal = parseFloatSafe(parent.line_total) || 0;
          const oldSub = parseFloatSafe(prevVal) || 0;
          const newSub = parseFloatSafe(value) || 0;
          const adjusted = parentTotal - (newSub - oldSub);
          parent.line_total = fmt2(Math.max(0, adjusted));
        }
      }
    }

    loadInvoiceData();
  }

  function addRowBelow(rowIndex){
    saveStateToUndo('Add row below');
    
    const items = allData.filter(d=>d.invoice_number===currentInvoice);
    items.sort((a,b)=>{
      const A=_parsePos(a.position), B=_parsePos(b.position);
      if(A.n!==B.n) return A.n-B.n;
      return _rankSuffix(A.s) - _rankSuffix(B.s);
    });
    const base = items[rowIndex];
    const insertPos = `${String(base.position).replace(/[^0-9].*$/,'')}${String.fromCharCode(65 + Math.floor(Math.random()*26))}`;
    const newRow = { invoice_number:currentInvoice, invoice_date:base.invoice_date, invoice_total:base.invoice_total, supplier:base.supplier, position:insertPos, part_number:'', quantity:'', unit:'', unit_price:'', line_total:'', net_weight:'', country_of_origin:base.country_of_origin };
    const firstIdx = allData.findIndex(d=>d===base);
    allData.splice(firstIdx+1,0,newRow);

    focusHint = { pos: insertPos, key: 'position' };
    loadInvoiceData();
  }

  // Restore parent total if deleting S/A subline
  function deleteRow(rowIndex){
    saveStateToUndo('Delete row');
    
    const items = allData.filter(d=>d.invoice_number===currentInvoice);
    items.sort((a,b)=>{
      const A=_parsePos(a.position), B=_parsePos(b.position);
      if(A.n!==B.n) return A.n-B.n;
      return _rankSuffix(A.s) - _rankSuffix(B.s);
    });
    const base = items[rowIndex];

    const posStr = String(base?.position || '');
    const isSub = /[SA]$/i.test(posStr);
    if(isSub){
      const basePos = posStr.replace(/[SA]$/i, '');
      const recs = allData.filter(d=>d.invoice_number===currentInvoice);
      const parent = recs.find(r => String(r.position||'') === basePos);
      if(parent){
        const parentTotal = parseFloatSafe(parent.line_total) || 0;
        const subAmt = parseFloatSafe(base.line_total) || 0;
        const restored = parentTotal + subAmt;
        parent.line_total = fmt2(Math.max(0, restored));
      }
    }

    const idx = allData.findIndex(d=> d===base);
    if(idx>=0){ allData.splice(idx,1); }

    loadInvoiceData();
  }

  function addBlankRowForCurrent(){
    if(!currentInvoice){ showAlert('Select an invoice first','error'); return; }
    
    saveStateToUndo('Add blank row');
    
    const items = allData.filter(d=>d.invoice_number===currentInvoice);
    const meta = items[0]||{};
    const newPos = '';
    const newRow = { invoice_number:currentInvoice, invoice_date:meta.invoice_date||'', invoice_total:meta.invoice_total||'', supplier:meta.supplier||'', position:newPos, part_number:'', quantity:'', unit:'', unit_price:'', line_total:'', net_weight:'', country_of_origin:meta.country_of_origin||'' };
    allData.push(newRow);
    focusHint = { pos: newPos, key: 'position' };
    loadInvoiceData();
  }

  function updateInvoiceField(field, value){
    saveStateToUndo(`Update ${field}`);
    allData.forEach(d=>{ if(d.invoice_number===currentInvoice){ d[field]=value; }});
  }
  
  function updateInvoiceTotal(value){ 
    saveStateToUndo('Update invoice total');
    updateInvoiceField('invoice_total', value); 
    recomputeStats(); 
  }

  function recomputeStats(){
    const items = allData.filter(d=>d.invoice_number===currentInvoice);
    const sum = items.reduce((acc,r)=> acc + (parseFloatSafe(r.line_total)||0), 0);
    const invTotal = parseFloatSafe(items[0]?.invoice_total);
    const diff = (isNaN(invTotal)?0:invTotal) - sum;
    document.getElementById('statSum').textContent = '$'+sum.toFixed(2);
    document.getElementById('statDiff').textContent = '$'+diff.toFixed(2);
  }

  function resetUpload(){ location.reload(); }

  /* =================== SUPPLIER MID LOOKUP HELPERS =================== */
  function stripDiacritics(s){ try { return s.normalize('NFKD').replace(/[\u0300-\u036f]/g,''); } catch(_) { return s; } }
  function normalizeSupplierName(s){
    return stripDiacritics(String(s||''))
      .toLowerCase()
      .replace(/&/g,' and ')
      .replace(/\b(gmbh|co\.?|kg|llc|inc\.?|ltd\.?|company|coatings|industrie|lackfabrik|the|and|of|factory|fabrik|sa|ag|gebr|geb\.)\b/gi,'')
      .replace(/[^a-z0-9]+/g,'')
      .trim();
  }
  function onlyConsonants(s){ return String(s||'').replace(/[aeiou]/gi,''); }
  function diceCoefficient(a,b){
    if(!a || !b) return 0;
    if(a === b) return 1;
    const grams = t => { const r=[]; for(let i=0;i<t.length-1;i++) r.push(t.slice(i,i+2)); return r; };
    const A=grams(a), B=grams(b);
    if(!A.length || !B.length) return 0;
    const map={}; let hit=0;
    A.forEach(g=>map[g]=(map[g]||0)+1);
    B.forEach(g=>{ if(map[g]){ hit++; map[g]--; }});
    return (2*hit)/(A.length+B.length);
  }
  function buildSupplierMidIndex(){
    supplierMidIndex = [];
    if(!Array.isArray(supplierMidDb)) return;
    supplierMidDb.forEach(row=>{
      const rawName = String(row['MANUFACTURERNAME'] ?? '').trim();
      const rawMid  = String(row['MANUFACTURERMID'] ?? '').trim();
      if(!rawName || !rawMid) return;
      const norm = normalizeSupplierName(rawName);
      supplierMidIndex.push({ raw: rawName, norm, cons: onlyConsonants(norm), mid: rawMid });
    });
  }
  function scoreSupplierCandidate(qNorm, qRaw, rec){
    const exact = qNorm === rec.norm ? 1 : 0;
    const starts = rec.norm.startsWith(qNorm) ? 0.95 : 0;
    const contains = rec.norm.includes(qNorm) || qNorm.includes(rec.norm) ? 0.85 : 0;
    const dice = diceCoefficient(qNorm, rec.norm);
    const qCons = onlyConsonants(qNorm);
    const consDice = diceCoefficient(qCons, rec.cons);
    let shortBoost = 0;
    if(qNorm.length >= 3 && qNorm.length <= 6){
      if(rec.norm.includes(qNorm)) shortBoost = 0.25;
      else if(rec.cons.includes(qCons)) shortBoost = 0.18;
    }
    return Math.max(exact, starts, contains, dice, consDice) + shortBoost;
  }
  function lookupSupplierMIDFromText(supplierText){
    const query = String(supplierText || '').trim();
    if (!query) return '';
    if (!Array.isArray(supplierMidIndex) || supplierMidIndex.length === 0) return '';
    const qNorm = normalizeSupplierName(query);
    if (!qNorm) return '';
    const candidates = supplierMidIndex.map(rec => ({
      rec,
      score: scoreSupplierCandidate(qNorm, query, rec)
    })).filter(c => c.score > 0.5);
    if (!candidates.length) return '';
    candidates.sort((a, b) => b.score - a.score);
    return candidates[0].rec.mid;
  }

  function extractBasePartNumber(fullPartNum){
    const s = String(fullPartNum || '').trim();
    const head = s.split('.')[0];
    const alnum = (head.match(/[A-Za-z0-9]+/)||[''])[0];
    if (alnum.length >= 5) return alnum.slice(0,5);
    if (alnum.length === 4) return alnum;
    const fallback = (s.match(/[A-Za-z0-9]{4,5}/)||[''])[0];
    return fallback || alnum || '';
  }
  function lookupTariffs(basePartNum){
    if(!mankiDb) return [];
    const part = mankiDb.find(row => String(row['PRIMARY PART NUM']) === basePartNum);
    if(!part) return [];
    const tariffs = [];
    for(let i=0; i<=5; i++){
      const col = i===0 ? 'TARIFF NUM' : `TARIFF NUM_${i}`;
      if(part[col]){
        const tariffStr = String(part[col]).replace(/\.0$/, '');
        tariffs.push(tariffStr);
      }
    }
    return tariffs;
  }
  function lookupHtsUom(htsCode){
    if(!htsCodesDb) return {uom1: '', uom2: ''};
    const hts = htsCodesDb.find(row => String(row['HTS Code']) === String(htsCode));
    if(!hts) return {uom1: '', uom2: ''};
    return { uom1: hts['UOM1'] || '', uom2: hts['UOM2'] || '' };
  }
  function getSteelAlumPartNumber(tariff, type){
    if(!steelAlumDb) return type === 'Steel' ? 'STEEL GENERIC' : 'ALUM GENERIC';
    const mapping = steelAlumDb.find(row => String(row['Tariff']).replace(/\.0$/, '') === String(tariff));
    if(mapping) return type === 'Steel' ? mapping['Steel'] : mapping['Aluminum'];
    return type === 'Steel' ? 'STEEL GENERIC' : 'ALUM GENERIC';
  }

  function exportToExcel(){
    if(!allData.length){ showAlert('No data to export','error'); return; }
    const wb = XLSX.utils.book_new();
    const byInv = {};
    allData.forEach(r=>{ if(!byInv[r.invoice_number]) byInv[r.invoice_number]=[]; byInv[r.invoice_number].push(r); });
    Object.keys(byInv).forEach(inv=>{
      const rows = byInv[inv].slice().sort((a,b)=>{
        const A=_parsePos(a.position), B=_parsePos(b.position);
        if(A.n!==B.n) return A.n-B.n;
        return _rankSuffix(A.s) - _rankSuffix(B.s);
      });
      const header = [
        ['Invoice', inv],
        ['Date', rows[0]?.invoice_date || ''],
        ['Supplier', rows[0]?.supplier || ''],
        ['Invoice Total', rows[0]?.invoice_total || ''],
        [],
        ['Pos','Part Number','Quantity','Unit','Unit Price','Line Total','Net Weight','Country']
      ];
      const body = rows.map(r=>[
        r.position||'', r.part_number||'', r.quantity||'', r.unit||'', r.unit_price||'', r.line_total||'', r.net_weight||'', r.country_of_origin||''
      ]);
      const ws = XLSX.utils.aoa_to_sheet([...header, ...body]);
      XLSX.utils.book_append_sheet(wb, ws, `INV_${String(inv).slice(-10)}`);
    });
    const out = XLSX.write(wb, {type:'array', bookType:'xlsx'});
    const blob = new Blob([out], {type:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = (uploadedPdfName?uploadedPdfName+'_':'')+'parsed_invoices.xlsx';
    document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
  }

  function exportToDescartes(){
    if(!mankiDb || !htsCodesDb || !steelAlumDb){
      showAlert('Database not loaded yet. Please wait or click Work Offline.','error');
      return;
    }
    if(!allData.length){ showAlert('No data to export','error'); return; }

    const items = allData.slice().sort((a,b)=>{
      const ai = String(a.invoice_number||''); const bi = String(b.invoice_number||'');
      if (ai !== bi) return ai.localeCompare(bi);
      const A=_parsePos(a.position), B=_parsePos(b.position);
      if(A.n!==B.n) return A.n-B.n;
      return _rankSuffix(A.s) - _rankSuffix(B.s);
    });

    const exportRows = [];
    const roundWeight = (val) => {
      const num = parseFloat(val);
      if (isNaN(num)) return '';
      if (num < 1) return 1;
      return Math.round(num);
    };

    const currentUiSupplierByInvoice = {};
    try{
      const uiSupplier = document.getElementById('statSupplier')?.value || '';
      const uiInvoice  = document.getElementById('statInvoice')?.textContent || '';
      if(uiInvoice){ currentUiSupplierByInvoice[uiInvoice] = uiSupplier; }
    }catch(_){}
    items.forEach(rec=>{
      const inv = rec.invoice_number;
      if(!currentUiSupplierByInvoice[inv]) currentUiSupplierByInvoice[inv] = rec.supplier || '';
    });

    items.forEach(item => {
      const isSteelLine = String(item.position||'').endsWith('S') || item.part_number === 'STEEL';
      const isAlumLine  = String(item.position||'').endsWith('A') || item.part_number === 'ALUMINUM';

      let buyerPartNum, supplierPartNum;
      if (!isSteelLine && !isAlumLine) {
        const basePart = extractBasePartNumber(item.part_number);
        buyerPartNum = basePart;
        supplierPartNum = basePart;
      } else {
        const parentPos = String(item.position||'').replace(/[SA]$/,'');
        const parentItem = items.find(it => it.invoice_number===item.invoice_number && it.position === parentPos);
        let tariffForSubline = null;
        if (parentItem) {
          const parentBase = extractBasePartNumber(parentItem.part_number);
          const parentTariffs = lookupTariffs(parentBase);
          tariffForSubline = parentTariffs.find(t => !String(t).startsWith('98') && !String(t).startsWith('99')) || null;
        }
        const subNum = tariffForSubline
          ? getSteelAlumPartNumber(tariffForSubline, isSteelLine ? 'Steel' : 'Aluminum')
          : (isSteelLine ? 'STEEL GENERIC' : 'ALUM GENERIC');
        buyerPartNum = subNum;
        supplierPartNum = subNum;
      }

      // CHANGED: Calculate unit price as item total / quantity
      let calculatedUnitPrice = '';
      const itemTotal = parseFloatSafe(item.line_total);
      const quantity = parseFloatSafe(item.quantity);
      if (!isNaN(itemTotal) && !isNaN(quantity) && quantity > 0) {
        calculatedUnitPrice = (itemTotal / quantity).toFixed(2);
      }

      const supplierForInvoice = (currentUiSupplierByInvoice[item.invoice_number] || item.supplier || '');
      const row = {
        'InvoiceNumber': item.invoice_number,
        'InvoiceDate': item.invoice_date,
        'InvoiceTotal': item.invoice_total,
        'SupplierMID': lookupSupplierMIDFromText(supplierForInvoice),
        'SupplierName': supplierForInvoice,
        'BuyerPartNumber': buyerPartNum,
        'SupplierPartNumber': supplierPartNum,
        'Quantity': item.quantity,
        'UnitOfMeasure': item.unit,
        'Description': '',
        'UnitPrice': calculatedUnitPrice,  // CHANGED: Now calculated from item total / quantity
        'ItemTotal': item.line_total,
        'CurrencyCode': '',
        'ExchangeRate': '',
        'CountryOfOrigin': item.country_of_origin,
        'CountryOfExport': '',
        'DateOfExport': '',
        'PortOfLading': '',
        'RelatedParty': '',
        'PO_Number': '',
        'PO_Date': '',
        'GrossWeight': '',
        'GrossWeightUnit': '',
        'NetWeight': roundWeight(item.net_weight),
        'TariffNumber': '',
        'TariffDescription': '',
        'Quantity1': '',
        'UnitOfMeasure1': '',
        'Quantity2': '',
        'UnitOfMeasure2': '',
        'Quantity3': '',
        'UnitOfMeasure3': '',
        'PrimarySPI': '',
        'SecondarySPI': '',
        'DeliverTo': '',
        'SoldTo': '',
        'SellerMID': '',
        'ShipperMID': '',
        'EntryDate': '',
        'ArrivalDate': '',
        'Carrier': '',
        'Vessel': '',
        'Voyage': '',
        'PortOfEntry': '',
        'PortOfUnloading': '',
        'LocationCode': '',
        'TotalCharges': '',
        'BillOfLadingNumber': '',
        'Container': '',
        'SecondaryTariffNumber': '',
        'SecondaryTariffdescription': '',
        'Secondary Quantity1': '',
        'Secondaryunitofmeasure1': '',
        'secondaryquantity2': '',
        'secondaryunitofmeasure2': '',
        'secondaryquantity3': '',
        'secondaryunitofmeasure3': '',
        'secondaryvalue': '',
        'FTZStatus': '',
        'FTZPrivilegedDate\u00a0': '',
        'ThirdTariffNumber': '',
        'ThirdTariffDescription': '',
        'ThirdTariffQuantity1': '',
        'ThirdTariffUnitofMeasure1': '',
        'ThirdTariffQuantity2': '',
        'ThirdTariffUnitofMeasure2': '',
        'ThirdTariffQuantity3': '',
        'ThirdTariffUnitofMeasure3': '',
        'Third Value': '',
        '4TariffNumber': '',
        '4TariffDescription': '',
        '4TariffQuantity1': '',
        '4TariffUnitofMeasure1': '',
        '4TariffQuantity2': '',
        '4TariffUnitofMeasure2': '',
        '4TariffQuantity3': '',
        '4TariffUnitofMeasure3': '',
        '4 Value': '',
        '5TariffNumber': '',
        '5TariffDescription': '',
        '5TariffQuantity1': '',
        '5TariffUnitofMeasure1': '',
        '5TariffQuantity2': '',
        '5TariffUnitofMeasure2': '',
        '5TariffQuantity3': '',
        '5TariffUnitofMeasure3': '',
        '5 Value': ''
      };

      if (isSteelLine || isAlumLine) {
        row['NetWeight'] = roundWeight(item.quantity);
      }

      const basePartNum = extractBasePartNumber(item.part_number);
      const tariffs = lookupTariffs(basePartNum);
      const tariffFields = ['TariffNumber', 'SecondaryTariffNumber', 'ThirdTariffNumber', '4TariffNumber', '5TariffNumber'];

      tariffs.forEach((tariff, idx) => {
        if(idx < tariffFields.length){
          row[tariffFields[idx]] = tariff;
          const startsWithExempt = String(tariff).startsWith('98') || String(tariff).startsWith('99');
          if(!startsWithExempt){
            const uomInfo = lookupHtsUom(tariff);
            if(idx === 0){
              row['Quantity1'] = roundWeight(item.net_weight);
              row['UnitOfMeasure1'] = uomInfo.uom1;
              if(uomInfo.uom2){ row['Quantity2'] = roundWeight(item.net_weight); row['UnitOfMeasure2'] = uomInfo.uom2; }
            } else if(idx === 1){
              row['Secondary Quantity1'] = roundWeight(item.net_weight);
              row['Secondaryunitofmeasure1'] = uomInfo.uom1;
              if(uomInfo.uom2){ row['secondaryquantity2'] = roundWeight(item.net_weight); row['secondaryunitofmeasure2'] = uomInfo.uom2; }
            } else if(idx === 2){
              row['ThirdTariffQuantity1'] = roundWeight(item.net_weight);
              row['ThirdTariffUnitofMeasure1'] = uomInfo.uom1;
              if(uomInfo.uom2){ row['ThirdTariffQuantity2'] = roundWeight(item.net_weight); row['ThirdTariffUnitofMeasure2'] = uomInfo.uom2; }
            } else if(idx === 3){
              row['4TariffQuantity1'] = roundWeight(item.net_weight);
              row['4TariffUnitofMeasure1'] = uomInfo.uom1;
              if(uomInfo.uom2){ row['4TariffQuantity2'] = roundWeight(item.net_weight); row['4TariffUnitofMeasure2'] = uomInfo.uom2; }
            } else if(idx === 4){
              row['5TariffQuantity1'] = roundWeight(item.net_weight);
              row['5TariffUnitofMeasure1'] = uomInfo.uom1;
              if(uomInfo.uom2){ row['5TariffQuantity2'] = roundWeight(item.net_weight); row['5TariffUnitofMeasure2'] = uomInfo.uom2; }
            }
          }
        }
      });

      if (isSteelLine) {
        row['TariffNumber'] = '99030133';
        row['SecondaryTariffNumber'] = '99038191';
        row['Secondary Quantity1'] = roundWeight(item.quantity);
        row['Secondaryunitofmeasure1'] = 'KG';
      }

      if (isAlumLine) {
        row['TariffNumber'] = '99030133';
        row['SecondaryTariffNumber'] = '99038508';
        row['Secondary Quantity1'] = roundWeight(item.quantity);
        row['Secondaryunitofmeasure1'] = 'KG';
      }

      exportRows.push(row);
    });

    const wb = XLSX.utils.book_new();
    const ws = XLSX.utils.json_to_sheet(exportRows);
    XLSX.utils.book_append_sheet(wb, ws, 'Descartes Export');

    const out = XLSX.write(wb, {type:'array', bookType:'xlsx'});
    const blob = new Blob([out], {type:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = (uploadedPdfName?uploadedPdfName+'_':'')+'descartes_export.xlsx';
    document.body.appendChild(a); a.click(); document.body.removeChild(a);
    URL.revokeObjectURL(url);

    showAlert('Descartes template exported successfully!', 'success');
  }
</script>

<!-- =================== NORMALIZATION HELPERS (unchanged) =================== -->
<script>
(function(){
  function normalizeWeirdSpacing(s){
    const esc = (ch)=>ch.replace(/[.*+?^${}()|[\]\\]/g,'\\$&');
    const squish = (word)=>{
      const pat = new RegExp(word.split('').map(esc).join('\\s*'),'ig');
      return (txt)=>txt.replace(pat, word);
    };
    const common = [
      'Steel','Aluminum','Packaging','Content','Quantity','per','PCS',
      'Total','net','weight','value','customs','KG','invoice','Country','origin','product'
    ];
    let out = String(s);
    for(const w of common){ out = squish(w)(out); }
    out = out
      .replace(/9903\.81\.91\s*-\s*S\s*t\s*e\s*e\s*l\s*\s*P\s*a\s*c\s*k\s*a\s*g\s*i\s*n\s*g/ig, '9903.81.91 - Steel Packaging')
      .replace(/9903\.85\.08\s*-\s*A\s*l\s*u\s*m\s*i\s*n\s*u\s*m\s*\s*C\s*o\s*n\s*t\s*e\s*n\s*t(?:\s*\(in\s*metallic\s*paint\))?/ig, '9903.85.08 - Aluminum Content (in metallic paint)');
    out = out
      .replace(/Total\s+net\s+steel\s+weight\s*(?:per\s*KG)?\s*:/ig, 'Total net steel weight per KG:')
      .replace(/Total\s+net\s+aluminum\s+weight\s*(?:per\s*KG)?\s*:/ig, 'Total net aluminum weight per KG:')
      .replace(/Steel\s*content\s*per\s*PCS\s*:/ig, 'Steel content per PCS:')
      .replace(/Aluminum\s*content\s*per\s*PCS\s*:/ig, 'Aluminum content per PCS:')
      .replace(/Quantity\s*per\s*PCS\s*:/ig, 'Quantity per PCS:')
      .replace(/Total\s+customs\s+value\s*:/ig, 'Total customs value:');
    out = out.replace(/(\bKG)\s*\/\s*[0-9][0-9.,]*\s*USD\b/ig, '$1');
    out = out.replace(/\s{2,}/g, ' ');
    return out;
  }

  const needNorm = (re)=>{
    if(!(re instanceof RegExp)) return false;
    const src = (re.source || '').toLowerCase();
    return /9903|steel|alum|customs\s+value|quantity\s*per\s*pcs|content\s*per\s*pcs|total\s+net\s+.*weight/.test(src);
  };

  const _origMatch = String.prototype.match;
  Object.defineProperty(String.prototype, '__origMatch', { value: _origMatch, configurable: true });

  String.prototype.match = function(re){
    try{
      if(needNorm(re)){
        const norm = normalizeWeirdSpacing(String(this));
        return _origMatch.call(norm, re);
      }
      return _origMatch.call(this, re);
    }catch(e){
      return _origMatch.call(this, re);
    }
  };

  if(RegExp.prototype.exec){
    const _origExec = RegExp.prototype.exec;
    Object.defineProperty(RegExp.prototype, '__origExec', { value: _origExec, configurable: true });
    RegExp.prototype.exec = function(str){
      try{
        if(needNorm(this)){
          const norm = normalizeWeirdSpacing(String(str));
          return _origExec.call(this, norm);
        }
        return _origExec.call(this, str);
      }catch(e){
        return _origExec.call(this, str);
      }
    };
  }
})();
</script>

<!-- =================== AUTO-REORDERING FOR S/A SUBLINES =================== -->
<script>
(function(){
  function reorderSteelAlum(arr){
    if(!Array.isArray(arr) || arr.length===0) return;
    const grouped={};
    arr.forEach(r=>{
      const inv=r.invoice_number||''; if(!grouped[inv]) grouped[inv]=[]; grouped[inv].push(r);
    });
    function numSuf(s){ return s===''?0:(s==='S'?1:2); }
    function parsePos(p){
      const m=String(p||'').match(/^(\d+(?:[.,]\d+)?)([A-Za-z]?)$/);
      if(!m) return {n:999999,s:''};
      return { n:parseFloat(String(m[1]).replace(',','.')), s:(m[2]||'').toUpperCase() };
    }
    Object.keys(grouped).forEach(inv=>{
      const items=grouped[inv];
      items.sort((a,b)=>{
        const A=parsePos(a.position), B=parsePos(b.position);
        if(A.n!==B.n) return A.n-B.n;
        return numSuf(A.s)-numSuf(B.s);
      });
    });
  }

  function detectDataArray(){
    const candidates=[];
    ['allData','invoiceData','items','rows','data','parsedData','invoices','lineItems'].forEach(name=>{
      if(typeof window[name]!=='undefined' && Array.isArray(window[name]) && window[name].length>0){
        const first=window[name][0]; if(first && typeof first==='object' && 'position' in first){
          candidates.push({name, ref:window[name]});
        }
      }
    });
    candidates.sort((a,b)=> (b.ref.length||0) - (a.ref.length||0));
    return candidates[0] || null;
  }

  function proxyWithAutoReorder(arr){
    const mutating = new Set(['push','pop','shift','unshift','splice','sort','reverse']);
    return new Proxy(arr, {
      get(target, prop, recv){
        const val = Reflect.get(target, prop, recv);
        if (typeof val === 'function' && mutating.has(prop)){
          return function(){
            const out = Array.prototype[prop].apply(target, arguments);
            try { reorderSteelAlum(target); } catch(e){}
            return out;
          };
        }
        return val;
      },
      set(target, prop, value, recv){
        const ok = Reflect.set(target, prop, value, recv);
        if (prop === 'length' || /^\d+$/.test(String(prop))){
          try { reorderSteelAlum(target); } catch(e){}
        }
        return ok;
      }
    });
  }

  function hookRenderIfPresent(){
    const names = ['renderTable','drawTable','buildTable','updateTable'];
    names.forEach(n=>{
      if (typeof window[n] === 'function'){
        const _f = window[n];
        window[n] = function(){
          try { if (window.__dataArrayRef) reorderSteelAlum(window.__dataArrayRef); } catch(e){}
          return _f.apply(this, arguments);
        };
      }
    });
  }

  const found = detectDataArray();
  if (found){
    window.__dataArrayName = found.name;
    window.__dataArrayRef  = found.ref;
    const proxied = proxyWithAutoReorder(found.ref);
    try { window[found.name] = proxied; } catch(_){ }
    try { reorderSteelAlum(window.__dataArrayRef); } catch(e){}
    hookRenderIfPresent();
    document.addEventListener('click', (e)=>{
      const id = (e.target && e.target.id || '').toLowerCase();
      if (id.includes('export')) {
        try { reorderSteelAlum(window.__dataArrayRef); } catch(_){ }
      }
    }, true);
  }
})();
</script>

<!-- =================== DB LOADER (timeout + fallback + offline) =================== -->
<script>
  const GITHUB_CONFIG = {
    owner: 'iffinc-ga',
    repo: 'all_in_one_manki',
    branch: 'main',
    filePath: 'updated_manki_db.xlsx'
  };

  const dbStatusEl = document.getElementById('dbStatus');
  const dbInfoEl = document.getElementById('dbInfo');
  const retryBtn = document.getElementById('retryDbBtn');
  const offlineBtn = document.getElementById('offlineBtn');

  retryBtn.addEventListener('click', ()=> loadDatabaseFromGitHub());
  offlineBtn.addEventListener('click', ()=> enterOfflineMode('Switched to offline mode by user.'));

  window.addEventListener('DOMContentLoaded', function() {
    // Wrap in try-catch to ensure page doesn't break
    try {
      loadDatabaseFromGitHub().catch(err => {
        console.error('[DB] Unhandled database loading error:', err);
        enterOfflineMode('Database loading encountered an error. Working in offline mode.');
      });
    } catch(err) {
      console.error('[DB] Critical error during database initialization:', err);
      enterOfflineMode('Database initialization failed. Working in offline mode.');
    }
    
    // Safety fallback: if DB still loading after 15 seconds, auto-switch to offline
    setTimeout(() => {
      if (dbStatusEl && dbStatusEl.className.includes('db-loading')) {
        console.warn('[DB] Auto-fallback: DB load took too long, switching to offline mode');
        enterOfflineMode('Database load timeout. Auto-switched to offline mode.');
      }
    }, 15000);
  });

  function setDbBanner(state, msg, info){
    const clsBase = 'db-status';
    dbStatusEl.className = clsBase+' '+(
      state==='loaded' ? 'db-loaded' :
      state==='loading' ? 'db-loading' :
      state==='error' ? 'db-error' : 'db-offline'
    );
    dbStatusEl.textContent = msg;
    if(info!=null) dbInfoEl.textContent = info;
  }

  function abortableFetch(url, timeoutMs=8000){
    const ctrl = new AbortController();
    const t = setTimeout(()=>ctrl.abort(), timeoutMs);
    return fetch(url, {signal: ctrl.signal}).finally(()=>clearTimeout(t));
  }

  async function loadDatabaseFromGitHub(){
    const { owner, repo, branch, filePath } = GITHUB_CONFIG;
    const remoteUrl = `https://raw.githubusercontent.com/${owner}/${repo}/${branch}/${filePath}`;
    const localUrl  = './updated_manki_db.xlsx';

    console.log('[DB] Starting database load from:', remoteUrl);
    setDbBanner('loading','Loading database...','Trying GitHub (8s timeout)‚Ä¶');
    try{
      const wb = await fetchAndReadWorkbook(remoteUrl, true);
      await hydrateDbsFromWorkbook(wb);
      setDbBanner('loaded', 'Database loaded ‚úì', `Loaded from GitHub at ${new Date().toLocaleString()}`);
      console.log('[DB] Successfully loaded from GitHub');
      return;
    }catch(err1){
      console.warn('[DB] GitHub load failed:', err1?.message || err1);
      setDbBanner('loading','Retrying from local file‚Ä¶','Looking for ./updated_manki_db.xlsx');
      try{
        const wb2 = await fetchAndReadWorkbook(localUrl, false);
        await hydrateDbsFromWorkbook(wb2);
        setDbBanner('loaded','Database loaded ‚úì (local fallback)', `Loaded from local file at ${new Date().toLocaleString()}`);
        console.log('[DB] Successfully loaded from local file');
        return;
      }catch(err2){
        console.warn('[DB] Local fallback failed:', err2?.message || err2);
        console.log('[DB] Entering offline mode');
        enterOfflineMode(`DB load failed. Working offline. You can still parse/edit and export (limited enrichment).`);
      }
    }
  }

  async function fetchAndReadWorkbook(url, useTimeout){
    try {
      const res = useTimeout ? await abortableFetch(url, 8000) : await fetch(url);
      if(!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);
      const buf = await res.arrayBuffer();
      return XLSX.read(new Uint8Array(buf), {type:'array'});
    } catch(err) {
      console.error('[DB] Fetch error:', err);
      throw err;
    }
  }

  async function hydrateDbsFromWorkbook(workbook){
    if(workbook.SheetNames.includes('UPDATED_MANKI_DB')){
      mankiDb = XLSX.utils.sheet_to_json(workbook.Sheets['UPDATED_MANKI_DB']);
    } else throw new Error('UPDATED_MANKI_DB sheet not found');

    if(workbook.SheetNames.includes('manki_hts_codes_with_uom')){
      htsCodesDb = XLSX.utils.sheet_to_json(workbook.Sheets['manki_hts_codes_with_uom']);
    } else throw new Error('manki_hts_codes_with_uom sheet not found');

    if(workbook.SheetNames.includes('Sheet1')){
      steelAlumDb = XLSX.utils.sheet_to_json(workbook.Sheets['Sheet1']);
    } else throw new Error('Sheet1 not found');

    if(workbook.SheetNames.includes('MID')){
      supplierMidDb = XLSX.utils.sheet_to_json(workbook.Sheets['MID'], {defval:''});
      buildSupplierMidIndex();
    } else {
      supplierMidDb = [];
      supplierMidIndex = [];
      console.warn('[MID] Sheet "MID" not found.');
    }
  }

  function enterOfflineMode(reason){
    // Ensure arrays, not null, so exportToDescartes gate passes
    mankiDb = mankiDb || [];
    htsCodesDb = htsCodesDb || [];
    steelAlumDb = steelAlumDb || [];
    supplierMidDb = supplierMidDb || [];
    supplierMidIndex = supplierMidIndex || [];
    setDbBanner('offline', 'Offline mode (DB skipped)', reason || 'You can continue without the DB.');
    showAlert('You are now working offline. You can parse, edit, and export (with limited enrichment).','success');
  }
</script>

</body>
</html>
