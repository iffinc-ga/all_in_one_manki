<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Invoice Parser – Manki (Steel/Aluminum Fix)</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;line-height:1.45;margin:0;background:#0b1020;color:#e9eef9}
    header{padding:18px 20px;background:#111733;border-bottom:1px solid #1e264a;position:sticky;top:0}
    h1{font-size:18px;margin:0;font-weight:700}
    .container{max-width:1100px;margin:24px auto;padding:0 16px}
    .panel{background:#0f1838;border:1px solid #233066;border-radius:14px;padding:16px;margin-bottom:16px;box-shadow:0 6px 16px rgba(0,0,0,.25)}
    .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
    input[type=file]{background:#0c1330;border:1px dashed #33407b;border-radius:10px;padding:12px;color:#cfd7ff}
    button{background:#3e63ff;border:none;color:#fff;padding:10px 14px;border-radius:10px;font-weight:600;cursor:pointer}
    button:disabled{opacity:.55;cursor:not-allowed}
    table{width:100%;border-collapse:collapse}
    th,td{padding:8px 10px;border-bottom:1px solid #223064;vertical-align:top}
    th{position:sticky;top:58px;background:#0b1536;text-align:left}
    code{background:#0a1130;border:1px solid #21306a;border-radius:8px;padding:2px 6px;color:#bfe3ff}
    .small{opacity:.8;font-size:12px}
    .tags{display:flex;gap:6px;flex-wrap:wrap}
    .tag{background:#122157;border:1px solid #2a3a7a;border-radius:999px;padding:4px 8px;font-size:12px}
    .ok{color:#8ef59e}
    .warn{color:#ffd479}
    details>summary{cursor:pointer;color:#9fb7ff}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media (max-width:900px){.grid{grid-template-columns:1fr}}
  </style>
</head>
<body>
  <header>
    <h1>Manki PDF Parser — Steel/Aluminum Normalization Fix</h1>
  </header>
  <div class="container">
    <div class="panel">
      <div class="row">
        <input id="file" type="file" accept="application/pdf" multiple />
        <button id="run" disabled>Parse PDF(s)</button>
        <span class="small">Drop-in replacement for <code>all_in_best_version.html</code>. Adds spacing normalization so patterns like <em>“St eel Packaging”</em> are read as <em>“Steel Packaging”</em>.</span>
      </div>
    </div>

    <div class="panel" id="summaryPanel">
      <div class="tags" id="summaryTags"></div>
      <div id="log" class="small" style="white-space:pre-wrap;margin-top:8px"></div>
    </div>

    <div class="panel">
      <table>
        <thead>
          <tr>
            <th style="width:120px">Invoice #</th>
            <th style="width:70px">POS</th>
            <th>Description</th>
            <th style="width:110px">Qty</th>
            <th style="width:90px">UOM</th>
            <th style="width:120px">Line Total (USD)</th>
            <th style="width:160px">Notes</th>
          </tr>
        </thead>
        <tbody id="rows"></tbody>
      </table>
    </div>

    <div class="panel">
      <details open>
        <summary>How this fix works</summary>
        <p>
          Some Manki PDFs split letters with stray spaces (e.g., <code>St eel</code>, <code>w eight</code>). Your original
          regex (e.g., matching <code>9903.81.91 - Steel Packaging</code>) won’t fire on those broken labels. This build stitches
          key labels back together via <code>normalizeWeirdSpacing()</code> <em>before</em> running the existing extraction, so the
          steel/aluminum sublines are found and emitted beneath the correct base item.
        </p>
        <div class="grid">
          <div>
            <h3>Normalized labels</h3>
            <ul>
              <li>Steel Packaging / Aluminum Content headers</li>
              <li>Total net steel/aluminum weight (… per KG)</li>
              <li>Steel/Aluminum content per PCS</li>
              <li>Quantity per PCS</li>
              <li>Total customs value</li>
            </ul>
          </div>
          <div>
            <h3>What you’ll see</h3>
            <ul>
              <li>S‑sublines created for each item when a steel block exists.</li>
              <li>Qty sourced from <em>Total net steel weight</em> when present, else computed from content × pieces.</li>
              <li>Line total taken from <em>Total customs value</em>.</li>
            </ul>
          </div>
        </div>
      </details>
    </div>
  </div>

  <!-- pdf.js v3 legacy build for widest compatibility on GitHub Pages -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    // Configure worker for GitHub Pages
    pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";

    const $ = (sel)=>document.querySelector(sel);
    const fileInput = $('#file');
    const runBtn = $('#run');
    const rowsEl = $('#rows');
    const tagsEl = $('#summaryTags');
    const logEl = $('#log');

    const log = (...a)=>{ logEl.textContent += a.join(' ') + "\n"; };

    fileInput.addEventListener('change', ()=>{
      runBtn.disabled = !fileInput.files?.length;
    });

    runBtn.addEventListener('click', async ()=>{
      rowsEl.innerHTML = '';
      tagsEl.innerHTML = '';
      logEl.textContent = '';
      const files = Array.from(fileInput.files||[]);
      for (const f of files){
        await parsePdfFile(f);
      }
    });

    async function parsePdfFile(file){
      const bytes = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({data:new Uint8Array(bytes)}).promise;
      let full = '';
      for (let p=1;p<=pdf.numPages;p++){
        const page = await pdf.getPage(p);
        const content = await page.getTextContent();
        const line = content.items.map(it=>('' + (it.str||'')).replace(/\s+/g,' ').trim()).join(' ');
        full += line + "\n";
      }
      log('Loaded', file.name, `(${pdf.numPages} pages)`);
      const result = parseManki(full, file.name);
      renderResult(result);
    }

    // ===== Normalization Core (the actual fix) =====
    function normalizeWeirdSpacing(s){
      // Helper: compress sequences like "s t e e l" back to "steel"
      const squish = (word)=>{
        const letters = word.split('').map(ch=>ch.replace(/[.*+?^${}()|[\]\\]/g,'\\$&')).join('\\s*');
        const r = new RegExp(letters,'ig');
        return (txt)=>txt.replace(r, word);
      };
      const pairs = [
        'Steel','Aluminum','Packaging','Content','Quantity','per','PCS','Total','net','weight','value','customs','KG','invoice','Country','origin','product'
      ];
      let out = s;
      // Generic pass: stitch common words
      for(const w of pairs){ out = squish(w)(out); }
      // Specific headers that often break across words
      out = out
        .replace(/9903\.81\.91\s*-\s*S\s*t\s*e\s*e\s*l\s*\s*P\s*a\s*c\s*k\s*a\s*g\s*i\s*n\s*g/ig, '9903.81.91 - Steel Packaging')
        .replace(/9903\.85\.08\s*-\s*A\s*l\s*u\s*m\s*i\s*n\s*u\s*m\s*\s*C\s*o\s*n\s*t\s*e\s*n\s*t/ig, '9903.85.08 - Aluminum Content')
        .replace(/Total\s+net\s+steel\s+weight\s*(?:per\s*KG)?\s*:/ig, 'Total net steel weight per KG:')
        .replace(/Total\s+net\s+aluminum\s+weight\s*(?:per\s*KG)?\s*:/ig, 'Total net aluminum weight per KG:')
        .replace(/Steel\s*content\s*per\s*PCS\s*:/ig, 'Steel content per PCS:')
        .replace(/Aluminum\s*content\s*per\s*PCS\s*:/ig, 'Aluminum content per PCS:')
        .replace(/Quantity\s*per\s*PCS\s*:/ig, 'Quantity per PCS:')
        .replace(/Total\s+customs\s+value\s*:/ig, 'Total customs value:')
      ;
      return out;
    }

    // ===== Parser =====
    function parseManki(rawText, filename){
      // Keep the original for context, but run the extraction on the normalized copy
      const text = normalizeWeirdSpacing(rawText);

      const items = [];
      const invoices = [];

      // Very lightweight invoice splitter (works for both sample PDFs)
      const invRe = /(Invoice\s*No\.?|Invoice\s*number|INVOICE)\s*[:#]?\s*(\d{6,10})/ig;
      let m; const marks = [];
      while((m = invRe.exec(text))){ marks.push({idx:m.index, no:m[2]}); }
      if(marks.length===0){
        // Fallback: Manki often prints 8-digit numbers that are invoice IDs near the top
        const alt = [...text.matchAll(/\n\s*(\d{8})\s*\n/g)].map(x=>({idx:x.index,no:x[1]}));
        if(alt.length) marks.push(...alt);
      }
      // Close ranges
      for(let i=0;i<marks.length;i++){
        const start = marks[i].idx;
        const end = i<marks.length-1 ? marks[i+1].idx : text.length;
        invoices.push({no: marks[i].no || `INV_${i+1}`, start, end});
      }

      const steelHeader = /9903\.81\.91\s*-\s*Steel\s*Packaging/i;
      const alumHeader  = /9903\.85\.08\s*-\s*Aluminum\s*Content/i;

      const bQty = /Quantity\s*per\s*PCS:\s*([\d,.]+)/i;
      const bSteelPer = /Steel\s*content\s*per\s*PCS:\s*([\d,.]+)\s*KG/i;
      const bAlumPer = /Aluminum\s*content\s*per\s*PCS:\s*([\d,.]+)\s*KG/i;
      const totSteelKg = /Total\s*net\s*steel\s*weight\s*(?:per\s*KG)?\s*:\s*([\d,.]+)\s*KG/i;
      const totAlumKg  = /Total\s*net\s*aluminum\s*weight\s*(?:per\s*KG)?\s*:\s*([\d,.]+)\s*KG/i;
      const customsUSD = /Total\s*customs\s*value\s*:\s*([\d,.]+)\s*USD/i;

      // Main item lines: use a broad heuristic (Manki prints POS like 1,0 2,0 etc)
      const baseLineRe = /(Pos:\s*(\d+[,.]?\d*))[\s\S]*?\n([\s\S]{0,200}?)(?=Pos:|\n\s*Country of Origin:|\n\s*Customs tariff nr:|\n\s*Net weight|\n\s*$)/ig;

      for(const inv of invoices){
        const slice = text.substring(inv.start, inv.end);
        const invNo = inv.no;

        // 1) collect base items with their local slices (so we can attach S/A lines below them)
        let mm; const localBase = [];
        while((mm = baseLineRe.exec(slice))){
          const pos = (mm[2]||'').replace(/,/g,'.');
          const desc = (mm[3]||'').replace(/\s+/g,' ').trim().slice(0,160);
          const anchorIdx = inv.start + mm.index;
          localBase.push({invNo, pos, desc, anchorIdx});
        }
        // If nothing matched, at least keep a sentinel to still extract steel blocks invoice‑wide
        if(localBase.length===0) localBase.push({invNo, pos:'', desc:'(no base lines detected)', anchorIdx:inv.start});

        // 2) push base items
        for(const b of localBase){
          items.push({invoice: b.invNo, pos: b.pos, desc: b.desc, qty: '', uom: '', total: '', notes: ''});
        }

        // 3) find each steel/alum block occurring after a base line anchor and attach to the closest base
        //    (in your original, this is where you sliced per-item and looked for the block)
        const blockEndGuard = /(9903\.81\.91|9903\.85\.08|Total\s+invoice\s+value|Country\s+of\s+origin|Net\s+product\s+value)/i;

        function* blocksOf(headerRe){
          let idx = 0;
          for(;;){
            const hit = slice.substring(idx).match(headerRe);
            if(!hit) return;
            const start = idx + hit.index;
            const after = slice.substring(start + hit[0].length);
            const endRel = after.search(blockEndGuard);
            const end = endRel>0 ? start + hit[0].length + endRel : inv.end - inv.start;
            yield slice.substring(start, end);
            idx = end;
          }
        }

        const sBlocks = [...blocksOf(steelHeader)];
        const aBlocks = [...blocksOf(alumHeader)];

        const attach = (kind, blk)=>{
          // Pull metrics
          const qpcs = numOrNull(get1(blk,bQty));
          const per   = numOrNull(get1(blk, kind==='S'? bSteelPer : bAlumPer));
          const totKg = numOrNull(get1(blk, kind==='S'? totSteelKg : totAlumKg));
          const usd   = numOrNull(get1(blk, customsUSD));

          let qtyKg = null;
          if(totKg!=null) qtyKg = totKg; else if(qpcs!=null && per!=null) qtyKg = qpcs*per;

          // Find closest base by text index (nearest anchor before this block)
          const blkIdx = slice.indexOf(blk);
          let best = localBase[0];
          for(const b of localBase){ if(b.anchorIdx-inv.start <= blkIdx) best = b; else break; }

          items.push({
            invoice: invNo,
            pos: best.pos ? (kind==='S' ? `${best.pos}S` : `${best.pos}A`) : (kind==='S'?'S':'A'),
            desc: kind==='S' ? 'Steel subline (9903.81.91)' : 'Aluminum subline (9903.85.08)',
            qty: qtyKg!=null ? fmt(qtyKg) : '',
            uom: qtyKg!=null ? 'KG' : '',
            total: usd!=null ? fmt(usd) : '',
            notes: summarizeBlock(kind, qpcs, per, totKg, usd)
          });
        };

        sBlocks.forEach(b=>attach('S', b));
        aBlocks.forEach(b=>attach('A', b));
      }

      return {items, invoices: invoices.map(i=>i.no), normalized: true};
    }

    function summarizeBlock(kind, qpcs, per, totKg, usd){
      const bits = [];
      if(qpcs!=null) bits.push(`Qty/PCS=${fmt(qpcs)}`);
      if(per!=null)  bits.push(`${kind==='S'?'Steel':'Alum'}/PCS=${fmt(per)} KG`);
      if(totKg!=null)bits.push(`TotalKG=${fmt(totKg)}`);
      if(usd!=null)  bits.push(`Customs=${fmt(usd)} USD`);
      return bits.join(' · ');
    }

    function get1(txt,re){ const m = txt.match(re); return m?m[1]:null; }
    function numOrNull(x){ if(x==null) return null; const n=parseFloat((''+x).replace(/,/g,'')); return isFinite(n)?n:null; }
    const fmt = (n)=> n==null?'' : (Math.round(n*100)/100).toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2});

    // ===== Render =====
    function renderResult(result){
      addTag(`Invoices: ${result.invoices.length}`);
      addTag(result.normalized? 'Normalization: ON':'Normalization: OFF', 'ok');

      for(const r of result.items){
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${esc(r.invoice||'')}</td>
          <td>${esc(r.pos||'')}</td>
          <td>${esc(r.desc||'')}</td>
          <td style="text-align:right">${esc(r.qty||'')}</td>
          <td>${esc(r.uom||'')}</td>
          <td style="text-align:right">${esc(r.total||'')}</td>
          <td class="small">${esc(r.notes||'')}</td>
        `;
        rowsEl.appendChild(tr);
      }

      log('Parsed', result.items.length, 'row(s).');
    }

    function addTag(text, tone){
      const span = document.createElement('span');
      span.className = 'tag' + (tone? ' '+tone : '');
      span.textContent = text;
      tagsEl.appendChild(span);
    }

    function esc(s){ return (s+'').replace(/[&<>"']/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c])); }
  </script>
</body>
</html>
